equalities
  =, not=, keyword, symbol
  == (looser, eg. (== 2.0 2))

list of '()
  first, rest, count, cons (front), conj, peek, pop

vector or vec []
  conj, first, last, nth, subvec (slice), count

set or #{}
  count
  clojure.set/
     union, intersection ,difference

hash-map or {}
  contains?, assoc, dissoc, keys, vals, count, get

functions
  defn, fn, #( %1 %2...)

conditionals
  if, not, if-not, case, cond (:else), let, nil?, false?, empty?

higher order fns
  map, filter, reduce

runtime polymophism
  (defn f ([] ..) ([a] ..) ([a & more ..))
  (defmulti) (defmethod)+

lazy sequences
  range, take, drop, repeat, inc, identity, iterate

sequence comprehensions
  (for [x (range 10) :when (odd? x)] (* x x))
  (for [x () y ()] ... x y)

creating functions
  partial, comp (compose), inc, dec, complement

refs
  ref, deref, @, ref-set, dosync, alter

atoms
  atom, @, do, compare-and-set!, swap!

macros
  defmacro, macroexpand, ` (quote), ~ (unquote, inside a quote)
  - they receive a forma as a parameter
  - the list they return is evaluated

datatypes
  defrecord (map? true), deftype, defprotocol, with-out-str

java interop
  . operator, #(.method %1), (Class/staticMethod params)

partition
  partition (offset from first item), partition-all

group-by
  juxt

